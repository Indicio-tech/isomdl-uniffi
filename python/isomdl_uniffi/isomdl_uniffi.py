# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import platform

# Used for default argument values
_DEFAULT = object()  # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_isomdl_uniffi_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(
            _UniffiLib.ffi_isomdl_uniffi_rustbuffer_reserve, rbuf, additional
        )

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_isomdl_uniffi_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity, self.len, self.data[0 : self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError(
                    "junk data left in buffer at end of consume_with_stream"
                )
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")


class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(
            self.len, self.data[0 : self.len]
        )


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset : self.offset + size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset : self.offset + size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")


class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t), "@N", v)


# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.


class InternalError(Exception):
    pass


class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """

    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(
            code=_UniffiRustCallStatus.CALL_SUCCESS,
            error_buf=_UniffiRustBuffer.default(),
        )

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"


def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)


def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result


def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError(
                "_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None"
            )
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError(
            "Invalid _UniffiRustCallStatus code: {}".format(call_status.code)
        )


def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))


def _uniffi_trait_interface_call_with_error(
    call_status, make_call, write_return_value, error_type, lower_error
):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))


class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = itertools.count()

    def insert(self, obj):
        with self._lock:
            handle = next(self._counter)
            self._map[handle] = obj
            return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError("_UniffiHandleMap.get: Invalid handle")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError("_UniffiHandleMap.remove: Invalid handle")

    def __len__(self):
        return len(self._map)


# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value


class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError(
                "'{}' object cannot be interpreted as an integer".format(
                    type(value).__name__
                )
            )
        if not isinstance(value, int):
            raise TypeError(
                "__index__ returned non-int (type {})".format(type(value).__name__)
            )
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError(
                "{} requires {} <= value < {}".format(
                    cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX
                )
            )


class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError(
                "__float__ returned non-float (type {})".format(type(value).__name__)
            )


# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()


# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)


def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)


def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("isomdl_uniffi")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib


def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 26
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_isomdl_uniffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError(
            "UniFFI contract version mismatch: try cleaning and rebuilding your project"
        )


def _uniffi_check_api_checksums(lib):
    if lib.uniffi_isomdl_uniffi_checksum_func_establish_session() != 53873:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_isomdl_uniffi_checksum_func_generate_test_mdl() != 21646:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_isomdl_uniffi_checksum_func_handle_response() != 42478:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_isomdl_uniffi_checksum_func_iso1801351_aamva_from_json() != 22886:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_isomdl_uniffi_checksum_func_iso1801351_from_json() != 46310:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_isomdl_uniffi_checksum_func_verified_response_as_json_string()
        != 24954
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_isomdl_uniffi_checksum_method_mdlpresentationsession_generate_response()
        != 18706
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_isomdl_uniffi_checksum_method_mdlpresentationsession_get_ble_ident()
        != 27464
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_isomdl_uniffi_checksum_method_mdlpresentationsession_get_qr_code_uri()
        != 59339
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_isomdl_uniffi_checksum_method_mdlpresentationsession_handle_request()
        != 50972
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_isomdl_uniffi_checksum_method_mdlpresentationsession_submit_response()
        != 12859
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_isomdl_uniffi_checksum_method_mdlpresentationsession_terminate_session()
        != 32687
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_isomdl_uniffi_checksum_method_mdoc_details() != 47403:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_isomdl_uniffi_checksum_method_mdoc_doctype() != 8025:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_isomdl_uniffi_checksum_method_mdoc_id() != 45880:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_isomdl_uniffi_checksum_method_mdoc_json() != 1636:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_isomdl_uniffi_checksum_method_mdoc_key_alias() != 9235:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_isomdl_uniffi_checksum_method_mdoc_stringify() != 16395:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_isomdl_uniffi_checksum_method_p256keypair_public_jwk() != 36332:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_isomdl_uniffi_checksum_method_p256keypair_sign() != 44060:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_isomdl_uniffi_checksum_constructor_mdlpresentationsession_new()
        != 18493
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_isomdl_uniffi_checksum_constructor_mdoc_create_and_sign() != 3320:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_isomdl_uniffi_checksum_constructor_mdoc_from_cbor_encoded_document()
        != 38241
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_isomdl_uniffi_checksum_constructor_mdoc_from_string() != 15398:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_isomdl_uniffi_checksum_constructor_mdoc_from_stringified_document()
        != 9578
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_isomdl_uniffi_checksum_constructor_mdoc_new_from_base64url_encoded_issuer_signed()
        != 55023
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_isomdl_uniffi_checksum_constructor_p256keypair_new() != 41043:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )


# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(
    None,
    ctypes.c_uint64,
    ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_FREE = ctypes.CFUNCTYPE(
    None,
    ctypes.c_uint64,
)
_UNIFFI_CALLBACK_INTERFACE_FREE = ctypes.CFUNCTYPE(
    None,
    ctypes.c_uint64,
)


class _UniffiForeignFuture(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_FREE),
    ]


class _UniffiForeignFutureStructU8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint8),
        ("call_status", _UniffiRustCallStatus),
    ]


_UNIFFI_FOREIGN_FUTURE_COMPLETE_U8 = ctypes.CFUNCTYPE(
    None,
    ctypes.c_uint64,
    _UniffiForeignFutureStructU8,
)


class _UniffiForeignFutureStructI8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int8),
        ("call_status", _UniffiRustCallStatus),
    ]


_UNIFFI_FOREIGN_FUTURE_COMPLETE_I8 = ctypes.CFUNCTYPE(
    None,
    ctypes.c_uint64,
    _UniffiForeignFutureStructI8,
)


class _UniffiForeignFutureStructU16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint16),
        ("call_status", _UniffiRustCallStatus),
    ]


_UNIFFI_FOREIGN_FUTURE_COMPLETE_U16 = ctypes.CFUNCTYPE(
    None,
    ctypes.c_uint64,
    _UniffiForeignFutureStructU16,
)


class _UniffiForeignFutureStructI16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int16),
        ("call_status", _UniffiRustCallStatus),
    ]


_UNIFFI_FOREIGN_FUTURE_COMPLETE_I16 = ctypes.CFUNCTYPE(
    None,
    ctypes.c_uint64,
    _UniffiForeignFutureStructI16,
)


class _UniffiForeignFutureStructU32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint32),
        ("call_status", _UniffiRustCallStatus),
    ]


_UNIFFI_FOREIGN_FUTURE_COMPLETE_U32 = ctypes.CFUNCTYPE(
    None,
    ctypes.c_uint64,
    _UniffiForeignFutureStructU32,
)


class _UniffiForeignFutureStructI32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int32),
        ("call_status", _UniffiRustCallStatus),
    ]


_UNIFFI_FOREIGN_FUTURE_COMPLETE_I32 = ctypes.CFUNCTYPE(
    None,
    ctypes.c_uint64,
    _UniffiForeignFutureStructI32,
)


class _UniffiForeignFutureStructU64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint64),
        ("call_status", _UniffiRustCallStatus),
    ]


_UNIFFI_FOREIGN_FUTURE_COMPLETE_U64 = ctypes.CFUNCTYPE(
    None,
    ctypes.c_uint64,
    _UniffiForeignFutureStructU64,
)


class _UniffiForeignFutureStructI64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int64),
        ("call_status", _UniffiRustCallStatus),
    ]


_UNIFFI_FOREIGN_FUTURE_COMPLETE_I64 = ctypes.CFUNCTYPE(
    None,
    ctypes.c_uint64,
    _UniffiForeignFutureStructI64,
)


class _UniffiForeignFutureStructF32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_float),
        ("call_status", _UniffiRustCallStatus),
    ]


_UNIFFI_FOREIGN_FUTURE_COMPLETE_F32 = ctypes.CFUNCTYPE(
    None,
    ctypes.c_uint64,
    _UniffiForeignFutureStructF32,
)


class _UniffiForeignFutureStructF64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_double),
        ("call_status", _UniffiRustCallStatus),
    ]


_UNIFFI_FOREIGN_FUTURE_COMPLETE_F64 = ctypes.CFUNCTYPE(
    None,
    ctypes.c_uint64,
    _UniffiForeignFutureStructF64,
)


class _UniffiForeignFutureStructPointer(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_void_p),
        ("call_status", _UniffiRustCallStatus),
    ]


_UNIFFI_FOREIGN_FUTURE_COMPLETE_POINTER = ctypes.CFUNCTYPE(
    None,
    ctypes.c_uint64,
    _UniffiForeignFutureStructPointer,
)


class _UniffiForeignFutureStructRustBuffer(ctypes.Structure):
    _fields_ = [
        ("return_value", _UniffiRustBuffer),
        ("call_status", _UniffiRustCallStatus),
    ]


_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER = ctypes.CFUNCTYPE(
    None,
    ctypes.c_uint64,
    _UniffiForeignFutureStructRustBuffer,
)


class _UniffiForeignFutureStructVoid(ctypes.Structure):
    _fields_ = [
        ("call_status", _UniffiRustCallStatus),
    ]


_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID = ctypes.CFUNCTYPE(
    None,
    ctypes.c_uint64,
    _UniffiForeignFutureStructVoid,
)
_UniffiLib.uniffi_isomdl_uniffi_fn_clone_inprocessrecord.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_clone_inprocessrecord.restype = ctypes.c_void_p
_UniffiLib.uniffi_isomdl_uniffi_fn_free_inprocessrecord.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_free_inprocessrecord.restype = None
_UniffiLib.uniffi_isomdl_uniffi_fn_clone_mdlsessionmanager.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_clone_mdlsessionmanager.restype = ctypes.c_void_p
_UniffiLib.uniffi_isomdl_uniffi_fn_free_mdlsessionmanager.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_free_mdlsessionmanager.restype = None
_UniffiLib.uniffi_isomdl_uniffi_fn_clone_mdlpresentationsession.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_clone_mdlpresentationsession.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_isomdl_uniffi_fn_free_mdlpresentationsession.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_free_mdlpresentationsession.restype = None
_UniffiLib.uniffi_isomdl_uniffi_fn_constructor_mdlpresentationsession_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_constructor_mdlpresentationsession_new.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdlpresentationsession_generate_response.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdlpresentationsession_generate_response.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdlpresentationsession_get_ble_ident.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdlpresentationsession_get_ble_ident.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdlpresentationsession_get_qr_code_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdlpresentationsession_get_qr_code_uri.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdlpresentationsession_handle_request.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdlpresentationsession_handle_request.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdlpresentationsession_submit_response.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdlpresentationsession_submit_response.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdlpresentationsession_terminate_session.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdlpresentationsession_terminate_session.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_isomdl_uniffi_fn_clone_mdoc.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_clone_mdoc.restype = ctypes.c_void_p
_UniffiLib.uniffi_isomdl_uniffi_fn_free_mdoc.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_free_mdoc.restype = None
_UniffiLib.uniffi_isomdl_uniffi_fn_constructor_mdoc_create_and_sign.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_constructor_mdoc_create_and_sign.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_isomdl_uniffi_fn_constructor_mdoc_from_cbor_encoded_document.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_constructor_mdoc_from_cbor_encoded_document.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_isomdl_uniffi_fn_constructor_mdoc_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_constructor_mdoc_from_string.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_isomdl_uniffi_fn_constructor_mdoc_from_stringified_document.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_constructor_mdoc_from_stringified_document.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_isomdl_uniffi_fn_constructor_mdoc_new_from_base64url_encoded_issuer_signed.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_constructor_mdoc_new_from_base64url_encoded_issuer_signed.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdoc_details.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdoc_details.restype = _UniffiRustBuffer
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdoc_doctype.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdoc_doctype.restype = _UniffiRustBuffer
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdoc_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdoc_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdoc_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdoc_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdoc_key_alias.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdoc_key_alias.restype = _UniffiRustBuffer
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdoc_stringify.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_method_mdoc_stringify.restype = _UniffiRustBuffer
_UniffiLib.uniffi_isomdl_uniffi_fn_clone_p256keypair.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_clone_p256keypair.restype = ctypes.c_void_p
_UniffiLib.uniffi_isomdl_uniffi_fn_free_p256keypair.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_free_p256keypair.restype = None
_UniffiLib.uniffi_isomdl_uniffi_fn_constructor_p256keypair_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_constructor_p256keypair_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_isomdl_uniffi_fn_method_p256keypair_public_jwk.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_method_p256keypair_public_jwk.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_isomdl_uniffi_fn_method_p256keypair_sign.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_method_p256keypair_sign.restype = _UniffiRustBuffer
_UniffiLib.uniffi_isomdl_uniffi_fn_func_establish_session.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_func_establish_session.restype = _UniffiRustBuffer
_UniffiLib.uniffi_isomdl_uniffi_fn_func_generate_test_mdl.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_func_generate_test_mdl.restype = ctypes.c_void_p
_UniffiLib.uniffi_isomdl_uniffi_fn_func_handle_response.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_func_handle_response.restype = _UniffiRustBuffer
_UniffiLib.uniffi_isomdl_uniffi_fn_func_iso1801351_aamva_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_func_iso1801351_aamva_from_json.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_isomdl_uniffi_fn_func_iso1801351_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_func_iso1801351_from_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_isomdl_uniffi_fn_func_verified_response_as_json_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_isomdl_uniffi_fn_func_verified_response_as_json_string.restype = (
    _UniffiRustBuffer
)
_UniffiLib.ffi_isomdl_uniffi_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_isomdl_uniffi_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_isomdl_uniffi_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_isomdl_uniffi_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_isomdl_uniffi_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_isomdl_uniffi_rustbuffer_free.restype = None
_UniffiLib.ffi_isomdl_uniffi_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_isomdl_uniffi_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_u8.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_u8.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_u8.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_u8.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_i8.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_i8.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_i8.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_i8.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_u16.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_u16.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_u16.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_u16.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_i16.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_i16.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_i16.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_i16.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_u32.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_u32.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_u32.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_u32.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_i32.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_i32.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_i32.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_i32.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_u64.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_u64.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_u64.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_u64.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_i64.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_i64.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_i64.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_i64.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_f32.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_f32.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_f32.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_f32.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_f64.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_f64.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_f64.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_f64.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_pointer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_pointer.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_pointer.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_pointer.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_pointer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_rust_buffer.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_rust_buffer.restype = (
    _UniffiRustBuffer
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_poll_void.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_void.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_cancel_void.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_void.argtypes = (ctypes.c_uint64,)
_UniffiLib.ffi_isomdl_uniffi_rust_future_free_void.restype = None
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_isomdl_uniffi_rust_future_complete_void.restype = None
_UniffiLib.uniffi_isomdl_uniffi_checksum_func_establish_session.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_func_establish_session.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_isomdl_uniffi_checksum_func_generate_test_mdl.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_func_generate_test_mdl.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_isomdl_uniffi_checksum_func_handle_response.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_func_handle_response.restype = ctypes.c_uint16
_UniffiLib.uniffi_isomdl_uniffi_checksum_func_iso1801351_aamva_from_json.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_func_iso1801351_aamva_from_json.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_isomdl_uniffi_checksum_func_iso1801351_from_json.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_func_iso1801351_from_json.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_isomdl_uniffi_checksum_func_verified_response_as_json_string.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_func_verified_response_as_json_string.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdlpresentationsession_generate_response.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdlpresentationsession_generate_response.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdlpresentationsession_get_ble_ident.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdlpresentationsession_get_ble_ident.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdlpresentationsession_get_qr_code_uri.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdlpresentationsession_get_qr_code_uri.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdlpresentationsession_handle_request.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdlpresentationsession_handle_request.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdlpresentationsession_submit_response.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdlpresentationsession_submit_response.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdlpresentationsession_terminate_session.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdlpresentationsession_terminate_session.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdoc_details.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdoc_details.restype = ctypes.c_uint16
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdoc_doctype.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdoc_doctype.restype = ctypes.c_uint16
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdoc_id.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdoc_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdoc_json.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdoc_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdoc_key_alias.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdoc_key_alias.restype = ctypes.c_uint16
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdoc_stringify.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_mdoc_stringify.restype = ctypes.c_uint16
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_p256keypair_public_jwk.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_p256keypair_public_jwk.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_p256keypair_sign.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_method_p256keypair_sign.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_isomdl_uniffi_checksum_constructor_mdlpresentationsession_new.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_constructor_mdlpresentationsession_new.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_isomdl_uniffi_checksum_constructor_mdoc_create_and_sign.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_constructor_mdoc_create_and_sign.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_isomdl_uniffi_checksum_constructor_mdoc_from_cbor_encoded_document.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_constructor_mdoc_from_cbor_encoded_document.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_isomdl_uniffi_checksum_constructor_mdoc_from_string.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_constructor_mdoc_from_string.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_isomdl_uniffi_checksum_constructor_mdoc_from_stringified_document.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_constructor_mdoc_from_stringified_document.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_isomdl_uniffi_checksum_constructor_mdoc_new_from_base64url_encoded_issuer_signed.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_constructor_mdoc_new_from_base64url_encoded_issuer_signed.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_isomdl_uniffi_checksum_constructor_p256keypair_new.argtypes = ()
_UniffiLib.uniffi_isomdl_uniffi_checksum_constructor_p256keypair_new.restype = (
    ctypes.c_uint16
)
_UniffiLib.ffi_isomdl_uniffi_uniffi_contract_version.argtypes = ()
_UniffiLib.ffi_isomdl_uniffi_uniffi_contract_version.restype = ctypes.c_uint32

_uniffi_check_contract_api_version(_UniffiLib)
# _uniffi_check_api_checksums(_UniffiLib)

# Public interface members begin here.


class _UniffiConverterInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i64"
    VALUE_MIN = -(2**63)
    VALUE_MAX = 2**63

    @staticmethod
    def read(buf):
        return buf.read_i64()

    @staticmethod
    def write(value, buf):
        buf.write_i64(value)


class _UniffiConverterBool:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)


class _UniffiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()


class _UniffiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def check_lower(value):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError(
                "a bytes-like object is required, not {!r}".format(type(value).__name__)
            )

    @staticmethod
    def write(value, buf):
        buf.write_i32(len(value))
        buf.write(value)


class InProcessRecordProtocol(typing.Protocol):
    pass


class InProcessRecord:
    _pointer: ctypes.c_void_p

    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(
                _UniffiLib.uniffi_isomdl_uniffi_fn_free_inprocessrecord, pointer
            )

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(
            _UniffiLib.uniffi_isomdl_uniffi_fn_clone_inprocessrecord, self._pointer
        )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


class _UniffiConverterTypeInProcessRecord:
    @staticmethod
    def lift(value: int):
        return InProcessRecord._make_instance_(value)

    @staticmethod
    def check_lower(value: InProcessRecord):
        if not isinstance(value, InProcessRecord):
            raise TypeError(
                "Expected InProcessRecord instance, {} found".format(
                    type(value).__name__
                )
            )

    @staticmethod
    def lower(value: InProcessRecordProtocol):
        if not isinstance(value, InProcessRecord):
            raise TypeError(
                "Expected InProcessRecord instance, {} found".format(
                    type(value).__name__
                )
            )
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: InProcessRecordProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class MdlPresentationSessionProtocol(typing.Protocol):
    def generate_response(
        self, permitted_items: "dict[str, dict[str, typing.List[str]]]"
    ):
        """
        Constructs the response to be sent from the holder to the reader containing
        the items of information the user has consented to share.

        Takes a HashMap of items the user has authorized the app to share, as well
        as the id of a key stored in the key manager to be used to sign the response.
        Returns a byte array containing the signed response to be returned to the
        reader.
        """

        raise NotImplementedError

    def get_ble_ident(
        self,
    ):
        """
        Returns the BLE identification
        """

        raise NotImplementedError

    def get_qr_code_uri(
        self,
    ):
        """
        Returns the generated QR code
        """

        raise NotImplementedError

    def handle_request(self, request: "bytes"):
        """
        Handle a request from a reader that is seeking information from the mDL holder.

        Takes the raw bytes received from the reader by the holder over the transmission
        technology. Returns a Vector of information items requested by the reader, or an
        error.
        """

        raise NotImplementedError

    def submit_response(self, signature: "bytes"):
        raise NotImplementedError

    def terminate_session(
        self,
    ):
        """
        Terminates the mDL exchange session.

        Returns the termination message to be transmitted to the reader.
        """

        raise NotImplementedError


class MdlPresentationSession:
    _pointer: ctypes.c_void_p

    def __init__(self, mdoc: "Mdoc", uuid: "Uuid"):
        """
        Begin the mDL presentation process for the holder by passing in the credential
        to be presented in the form of an [Mdoc] object.

        Initializes the presentation session for an ISO 18013-5 mDL and stores
        the session state object in the device storage_manager.

        Arguments:
        mdoc: the Mdoc to be presented, as an [Mdoc] object
        uuid: the Bluetooth Low Energy Client Central Mode UUID to be used

        Returns:
        A Result, with the `Ok` containing a tuple consisting of an enum representing
        the state of the presentation, a String containing the QR code URI, and a
        String containing the BLE ident.

        """

        _UniffiConverterTypeMdoc.check_lower(mdoc)

        _UniffiConverterTypeUuid.check_lower(uuid)

        self._pointer = _uniffi_rust_call_with_error(
            _UniffiConverterTypeSessionError,
            _UniffiLib.uniffi_isomdl_uniffi_fn_constructor_mdlpresentationsession_new,
            _UniffiConverterTypeMdoc.lower(mdoc),
            _UniffiConverterTypeUuid.lower(uuid),
        )

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(
                _UniffiLib.uniffi_isomdl_uniffi_fn_free_mdlpresentationsession, pointer
            )

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(
            _UniffiLib.uniffi_isomdl_uniffi_fn_clone_mdlpresentationsession,
            self._pointer,
        )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    def generate_response(
        self, permitted_items: "dict[str, dict[str, typing.List[str]]]"
    ) -> "bytes":
        """
        Constructs the response to be sent from the holder to the reader containing
        the items of information the user has consented to share.

        Takes a HashMap of items the user has authorized the app to share, as well
        as the id of a key stored in the key manager to be used to sign the response.
        Returns a byte array containing the signed response to be returned to the
        reader.
        """

        _UniffiConverterMapStringMapStringSequenceString.check_lower(permitted_items)

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call_with_error(
                _UniffiConverterTypeSignatureError,
                _UniffiLib.uniffi_isomdl_uniffi_fn_method_mdlpresentationsession_generate_response,
                self._uniffi_clone_pointer(),
                _UniffiConverterMapStringMapStringSequenceString.lower(permitted_items),
            )
        )

    def get_ble_ident(
        self,
    ) -> "bytes":
        """
        Returns the BLE identification
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(
                _UniffiLib.uniffi_isomdl_uniffi_fn_method_mdlpresentationsession_get_ble_ident,
                self._uniffi_clone_pointer(),
            )
        )

    def get_qr_code_uri(
        self,
    ) -> "str":
        """
        Returns the generated QR code
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(
                _UniffiLib.uniffi_isomdl_uniffi_fn_method_mdlpresentationsession_get_qr_code_uri,
                self._uniffi_clone_pointer(),
            )
        )

    def handle_request(self, request: "bytes") -> "typing.List[ItemsRequest]":
        """
        Handle a request from a reader that is seeking information from the mDL holder.

        Takes the raw bytes received from the reader by the holder over the transmission
        technology. Returns a Vector of information items requested by the reader, or an
        error.
        """

        _UniffiConverterBytes.check_lower(request)

        return _UniffiConverterSequenceTypeItemsRequest.lift(
            _uniffi_rust_call_with_error(
                _UniffiConverterTypeRequestError,
                _UniffiLib.uniffi_isomdl_uniffi_fn_method_mdlpresentationsession_handle_request,
                self._uniffi_clone_pointer(),
                _UniffiConverterBytes.lower(request),
            )
        )

    def submit_response(self, signature: "bytes") -> "bytes":
        _UniffiConverterBytes.check_lower(signature)

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call_with_error(
                _UniffiConverterTypeSignatureError,
                _UniffiLib.uniffi_isomdl_uniffi_fn_method_mdlpresentationsession_submit_response,
                self._uniffi_clone_pointer(),
                _UniffiConverterBytes.lower(signature),
            )
        )

    def terminate_session(
        self,
    ) -> "bytes":
        """
        Terminates the mDL exchange session.

        Returns the termination message to be transmitted to the reader.
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call_with_error(
                _UniffiConverterTypeTerminationError,
                _UniffiLib.uniffi_isomdl_uniffi_fn_method_mdlpresentationsession_terminate_session,
                self._uniffi_clone_pointer(),
            )
        )


class _UniffiConverterTypeMdlPresentationSession:
    @staticmethod
    def lift(value: int):
        return MdlPresentationSession._make_instance_(value)

    @staticmethod
    def check_lower(value: MdlPresentationSession):
        if not isinstance(value, MdlPresentationSession):
            raise TypeError(
                "Expected MdlPresentationSession instance, {} found".format(
                    type(value).__name__
                )
            )

    @staticmethod
    def lower(value: MdlPresentationSessionProtocol):
        if not isinstance(value, MdlPresentationSession):
            raise TypeError(
                "Expected MdlPresentationSession instance, {} found".format(
                    type(value).__name__
                )
            )
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MdlPresentationSessionProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class MdlSessionManagerProtocol(typing.Protocol):
    pass


class MdlSessionManager:
    _pointer: ctypes.c_void_p

    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(
                _UniffiLib.uniffi_isomdl_uniffi_fn_free_mdlsessionmanager, pointer
            )

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(
            _UniffiLib.uniffi_isomdl_uniffi_fn_clone_mdlsessionmanager, self._pointer
        )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


class _UniffiConverterTypeMdlSessionManager:
    @staticmethod
    def lift(value: int):
        return MdlSessionManager._make_instance_(value)

    @staticmethod
    def check_lower(value: MdlSessionManager):
        if not isinstance(value, MdlSessionManager):
            raise TypeError(
                "Expected MdlSessionManager instance, {} found".format(
                    type(value).__name__
                )
            )

    @staticmethod
    def lower(value: MdlSessionManagerProtocol):
        if not isinstance(value, MdlSessionManager):
            raise TypeError(
                "Expected MdlSessionManager instance, {} found".format(
                    type(value).__name__
                )
            )
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MdlSessionManagerProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class MdocProtocol(typing.Protocol):
    def details(
        self,
    ):
        """
        Simple representation of mdoc namespace and data elements for display in the UI.
        """

        raise NotImplementedError

    def doctype(
        self,
    ):
        """
        The document type of this mdoc, for example `org.iso.18013.5.1.mDL`.
        """

        raise NotImplementedError

    def id(
        self,
    ):
        """
        The local ID of this credential.
        """

        raise NotImplementedError

    def json(
        self,
    ):
        """
        Serialize as JSON
        """

        raise NotImplementedError

    def key_alias(
        self,
    ):
        raise NotImplementedError

    def stringify(
        self,
    ):
        """
        Serialize to CBOR
        """

        raise NotImplementedError


class Mdoc:
    _pointer: ctypes.c_void_p

    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_isomdl_uniffi_fn_free_mdoc, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(
            _UniffiLib.uniffi_isomdl_uniffi_fn_clone_mdoc, self._pointer
        )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def create_and_sign(
        cls,
        doc_type: "str",
        namespaces: "dict[str, dict[str, bytes]]",
        holder_jwk: "str",
        iaca_cert_perm: "str",
        iaca_key_perm: "str",
    ):
        _UniffiConverterString.check_lower(doc_type)

        _UniffiConverterMapStringMapStringBytes.check_lower(namespaces)

        _UniffiConverterString.check_lower(holder_jwk)

        _UniffiConverterString.check_lower(iaca_cert_perm)

        _UniffiConverterString.check_lower(iaca_key_perm)

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(
            _UniffiConverterTypeMdocInitError,
            _UniffiLib.uniffi_isomdl_uniffi_fn_constructor_mdoc_create_and_sign,
            _UniffiConverterString.lower(doc_type),
            _UniffiConverterMapStringMapStringBytes.lower(namespaces),
            _UniffiConverterString.lower(holder_jwk),
            _UniffiConverterString.lower(iaca_cert_perm),
            _UniffiConverterString.lower(iaca_key_perm),
        )
        return cls._make_instance_(pointer)

    @classmethod
    def from_cbor_encoded_document(
        cls, cbor_encoded_document: "bytes", key_alias: "KeyAlias"
    ):
        """
        Construct a SpruceKit MDoc from a cbor-encoded
        [spruceid/isomdl `Document`](https://github.com/spruceid/isomdl/blob/main/src/presentation/device.rs#L145-L152)
        """

        _UniffiConverterBytes.check_lower(cbor_encoded_document)

        _UniffiConverterTypeKeyAlias.check_lower(key_alias)

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(
            _UniffiConverterTypeMdocInitError,
            _UniffiLib.uniffi_isomdl_uniffi_fn_constructor_mdoc_from_cbor_encoded_document,
            _UniffiConverterBytes.lower(cbor_encoded_document),
            _UniffiConverterTypeKeyAlias.lower(key_alias),
        )
        return cls._make_instance_(pointer)

    @classmethod
    def from_string(cls, stringified_document: "str"):
        """
        Parse an MDoc from a stringified document with a default key alias.
        This is a convenience method for parsing mdocs where the key alias is not critical.
        """

        _UniffiConverterString.check_lower(stringified_document)

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(
            _UniffiConverterTypeMdocInitError,
            _UniffiLib.uniffi_isomdl_uniffi_fn_constructor_mdoc_from_string,
            _UniffiConverterString.lower(stringified_document),
        )
        return cls._make_instance_(pointer)

    @classmethod
    def from_stringified_document(
        cls, stringified_document: "str", key_alias: "KeyAlias"
    ):
        """
        Compatibility feature: construct an MDoc from a
        [stringified spruceid/isomdl `Document`](https://github.com/spruceid/isomdl/blob/main/src/presentation/mod.rs#L100)
        """

        _UniffiConverterString.check_lower(stringified_document)

        _UniffiConverterTypeKeyAlias.check_lower(key_alias)

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(
            _UniffiConverterTypeMdocInitError,
            _UniffiLib.uniffi_isomdl_uniffi_fn_constructor_mdoc_from_stringified_document,
            _UniffiConverterString.lower(stringified_document),
            _UniffiConverterTypeKeyAlias.lower(key_alias),
        )
        return cls._make_instance_(pointer)

    @classmethod
    def new_from_base64url_encoded_issuer_signed(
        cls, base64url_encoded_issuer_signed: "str", key_alias: "KeyAlias"
    ):
        """
        Construct a new MDoc from base64url-encoded IssuerSigned.
        """

        _UniffiConverterString.check_lower(base64url_encoded_issuer_signed)

        _UniffiConverterTypeKeyAlias.check_lower(key_alias)

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(
            _UniffiConverterTypeMdocInitError,
            _UniffiLib.uniffi_isomdl_uniffi_fn_constructor_mdoc_new_from_base64url_encoded_issuer_signed,
            _UniffiConverterString.lower(base64url_encoded_issuer_signed),
            _UniffiConverterTypeKeyAlias.lower(key_alias),
        )
        return cls._make_instance_(pointer)

    def details(
        self,
    ) -> "dict[Namespace, typing.List[Element]]":
        """
        Simple representation of mdoc namespace and data elements for display in the UI.
        """

        return _UniffiConverterMapTypeNamespaceSequenceTypeElement.lift(
            _uniffi_rust_call(
                _UniffiLib.uniffi_isomdl_uniffi_fn_method_mdoc_details,
                self._uniffi_clone_pointer(),
            )
        )

    def doctype(
        self,
    ) -> "str":
        """
        The document type of this mdoc, for example `org.iso.18013.5.1.mDL`.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(
                _UniffiLib.uniffi_isomdl_uniffi_fn_method_mdoc_doctype,
                self._uniffi_clone_pointer(),
            )
        )

    def id(
        self,
    ) -> "Uuid":
        """
        The local ID of this credential.
        """

        return _UniffiConverterTypeUuid.lift(
            _uniffi_rust_call(
                _UniffiLib.uniffi_isomdl_uniffi_fn_method_mdoc_id,
                self._uniffi_clone_pointer(),
            )
        )

    def json(
        self,
    ) -> "str":
        """
        Serialize as JSON
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(
                _UniffiConverterTypeMdocEncodingError,
                _UniffiLib.uniffi_isomdl_uniffi_fn_method_mdoc_json,
                self._uniffi_clone_pointer(),
            )
        )

    def key_alias(
        self,
    ) -> "KeyAlias":
        return _UniffiConverterTypeKeyAlias.lift(
            _uniffi_rust_call(
                _UniffiLib.uniffi_isomdl_uniffi_fn_method_mdoc_key_alias,
                self._uniffi_clone_pointer(),
            )
        )

    def stringify(
        self,
    ) -> "str":
        """
        Serialize to CBOR
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(
                _UniffiConverterTypeMdocEncodingError,
                _UniffiLib.uniffi_isomdl_uniffi_fn_method_mdoc_stringify,
                self._uniffi_clone_pointer(),
            )
        )


class _UniffiConverterTypeMdoc:
    @staticmethod
    def lift(value: int):
        return Mdoc._make_instance_(value)

    @staticmethod
    def check_lower(value: Mdoc):
        if not isinstance(value, Mdoc):
            raise TypeError(
                "Expected Mdoc instance, {} found".format(type(value).__name__)
            )

    @staticmethod
    def lower(value: MdocProtocol):
        if not isinstance(value, Mdoc):
            raise TypeError(
                "Expected Mdoc instance, {} found".format(type(value).__name__)
            )
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MdocProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class P256KeyPairProtocol(typing.Protocol):
    def public_jwk(
        self,
    ):
        raise NotImplementedError

    def sign(self, msg: "bytes"):
        raise NotImplementedError


class P256KeyPair:
    _pointer: ctypes.c_void_p

    def __init__(
        self,
    ):
        self._pointer = _uniffi_rust_call(
            _UniffiLib.uniffi_isomdl_uniffi_fn_constructor_p256keypair_new,
        )

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(
                _UniffiLib.uniffi_isomdl_uniffi_fn_free_p256keypair, pointer
            )

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(
            _UniffiLib.uniffi_isomdl_uniffi_fn_clone_p256keypair, self._pointer
        )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    def public_jwk(
        self,
    ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(
                _UniffiLib.uniffi_isomdl_uniffi_fn_method_p256keypair_public_jwk,
                self._uniffi_clone_pointer(),
            )
        )

    def sign(self, msg: "bytes") -> "bytes":
        _UniffiConverterBytes.check_lower(msg)

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(
                _UniffiLib.uniffi_isomdl_uniffi_fn_method_p256keypair_sign,
                self._uniffi_clone_pointer(),
                _UniffiConverterBytes.lower(msg),
            )
        )


class _UniffiConverterTypeP256KeyPair:
    @staticmethod
    def lift(value: int):
        return P256KeyPair._make_instance_(value)

    @staticmethod
    def check_lower(value: P256KeyPair):
        if not isinstance(value, P256KeyPair):
            raise TypeError(
                "Expected P256KeyPair instance, {} found".format(type(value).__name__)
            )

    @staticmethod
    def lower(value: P256KeyPairProtocol):
        if not isinstance(value, P256KeyPair):
            raise TypeError(
                "Expected P256KeyPair instance, {} found".format(type(value).__name__)
            )
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: P256KeyPairProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class Element:
    """
    Simple representation of an mdoc data element.
    """

    identifier: "str"
    """
    Name of the data element.
    """

    value: "typing.Optional[str]"
    """
    JSON representation of the data element, missing if the value cannot be represented as JSON.
    """

    def __init__(self, *, identifier: "str", value: "typing.Optional[str]"):
        self.identifier = identifier
        self.value = value

    def __str__(self):
        return "Element(identifier={}, value={})".format(self.identifier, self.value)

    def __eq__(self, other):
        if self.identifier != other.identifier:
            return False
        if self.value != other.value:
            return False
        return True


class _UniffiConverterTypeElement(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Element(
            identifier=_UniffiConverterString.read(buf),
            value=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.identifier)
        _UniffiConverterOptionalString.check_lower(value.value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.identifier, buf)
        _UniffiConverterOptionalString.write(value.value, buf)


class ItemsRequest:
    doc_type: "str"
    namespaces: "dict[str, dict[str, bool]]"

    def __init__(self, *, doc_type: "str", namespaces: "dict[str, dict[str, bool]]"):
        self.doc_type = doc_type
        self.namespaces = namespaces

    def __str__(self):
        return "ItemsRequest(doc_type={}, namespaces={})".format(
            self.doc_type, self.namespaces
        )

    def __eq__(self, other):
        if self.doc_type != other.doc_type:
            return False
        if self.namespaces != other.namespaces:
            return False
        return True


class _UniffiConverterTypeItemsRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ItemsRequest(
            doc_type=_UniffiConverterString.read(buf),
            namespaces=_UniffiConverterMapStringMapStringBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.doc_type)
        _UniffiConverterMapStringMapStringBool.check_lower(value.namespaces)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.doc_type, buf)
        _UniffiConverterMapStringMapStringBool.write(value.namespaces, buf)


class MdlReaderResponseData:
    state: "MdlSessionManager"
    verified_response: "dict[str, dict[str, MDocItem]]"
    """
    Contains the namespaces for the mDL directly, without top-level doc types
    """

    issuer_authentication: "AuthenticationStatus"
    """
    Outcome of issuer authentication.
    """

    device_authentication: "AuthenticationStatus"
    """
    Outcome of device authentication.
    """

    errors: "typing.Optional[str]"
    """
    Errors that occurred during response processing.
    """

    def __init__(
        self,
        *,
        state: "MdlSessionManager",
        verified_response: "dict[str, dict[str, MDocItem]]",
        issuer_authentication: "AuthenticationStatus",
        device_authentication: "AuthenticationStatus",
        errors: "typing.Optional[str]",
    ):
        self.state = state
        self.verified_response = verified_response
        self.issuer_authentication = issuer_authentication
        self.device_authentication = device_authentication
        self.errors = errors

    def __str__(self):
        return "MdlReaderResponseData(state={}, verified_response={}, issuer_authentication={}, device_authentication={}, errors={})".format(
            self.state,
            self.verified_response,
            self.issuer_authentication,
            self.device_authentication,
            self.errors,
        )

    def __eq__(self, other):
        if self.state != other.state:
            return False
        if self.verified_response != other.verified_response:
            return False
        if self.issuer_authentication != other.issuer_authentication:
            return False
        if self.device_authentication != other.device_authentication:
            return False
        if self.errors != other.errors:
            return False
        return True


class _UniffiConverterTypeMdlReaderResponseData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MdlReaderResponseData(
            state=_UniffiConverterTypeMdlSessionManager.read(buf),
            verified_response=_UniffiConverterMapStringMapStringTypeMDocItem.read(buf),
            issuer_authentication=_UniffiConverterTypeAuthenticationStatus.read(buf),
            device_authentication=_UniffiConverterTypeAuthenticationStatus.read(buf),
            errors=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeMdlSessionManager.check_lower(value.state)
        _UniffiConverterMapStringMapStringTypeMDocItem.check_lower(
            value.verified_response
        )
        _UniffiConverterTypeAuthenticationStatus.check_lower(
            value.issuer_authentication
        )
        _UniffiConverterTypeAuthenticationStatus.check_lower(
            value.device_authentication
        )
        _UniffiConverterOptionalString.check_lower(value.errors)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeMdlSessionManager.write(value.state, buf)
        _UniffiConverterMapStringMapStringTypeMDocItem.write(
            value.verified_response, buf
        )
        _UniffiConverterTypeAuthenticationStatus.write(value.issuer_authentication, buf)
        _UniffiConverterTypeAuthenticationStatus.write(value.device_authentication, buf)
        _UniffiConverterOptionalString.write(value.errors, buf)


class MdlReaderSessionData:
    state: "MdlSessionManager"
    uuid: "Uuid"
    request: "bytes"
    ble_ident: "bytes"

    def __init__(
        self,
        *,
        state: "MdlSessionManager",
        uuid: "Uuid",
        request: "bytes",
        ble_ident: "bytes",
    ):
        self.state = state
        self.uuid = uuid
        self.request = request
        self.ble_ident = ble_ident

    def __str__(self):
        return (
            "MdlReaderSessionData(state={}, uuid={}, request={}, ble_ident={})".format(
                self.state, self.uuid, self.request, self.ble_ident
            )
        )

    def __eq__(self, other):
        if self.state != other.state:
            return False
        if self.uuid != other.uuid:
            return False
        if self.request != other.request:
            return False
        if self.ble_ident != other.ble_ident:
            return False
        return True


class _UniffiConverterTypeMdlReaderSessionData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MdlReaderSessionData(
            state=_UniffiConverterTypeMdlSessionManager.read(buf),
            uuid=_UniffiConverterTypeUuid.read(buf),
            request=_UniffiConverterBytes.read(buf),
            ble_ident=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeMdlSessionManager.check_lower(value.state)
        _UniffiConverterTypeUuid.check_lower(value.uuid)
        _UniffiConverterBytes.check_lower(value.request)
        _UniffiConverterBytes.check_lower(value.ble_ident)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeMdlSessionManager.write(value.state, buf)
        _UniffiConverterTypeUuid.write(value.uuid, buf)
        _UniffiConverterBytes.write(value.request, buf)
        _UniffiConverterBytes.write(value.ble_ident, buf)


class AuthenticationStatus(enum.Enum):
    VALID = 0

    INVALID = 1

    UNCHECKED = 2


class _UniffiConverterTypeAuthenticationStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AuthenticationStatus.VALID
        if variant == 2:
            return AuthenticationStatus.INVALID
        if variant == 3:
            return AuthenticationStatus.UNCHECKED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == AuthenticationStatus.VALID:
            return
        if value == AuthenticationStatus.INVALID:
            return
        if value == AuthenticationStatus.UNCHECKED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == AuthenticationStatus.VALID:
            buf.write_i32(1)
        if value == AuthenticationStatus.INVALID:
            buf.write_i32(2)
        if value == AuthenticationStatus.UNCHECKED:
            buf.write_i32(3)


# KeyTransformationError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class KeyTransformationError(Exception):
    pass


_UniffiTempKeyTransformationError = KeyTransformationError


class KeyTransformationError:  # type: ignore
    class ToPkcs8(_UniffiTempKeyTransformationError):
        def __init__(self, value):
            super().__init__(
                ", ".join(
                    [
                        "value={!r}".format(value),
                    ]
                )
            )
            self.value = value

        def __repr__(self):
            return "KeyTransformationError.ToPkcs8({})".format(str(self))

    _UniffiTempKeyTransformationError.ToPkcs8 = ToPkcs8  # type: ignore

    class FromPkcs8(_UniffiTempKeyTransformationError):
        def __init__(self, value):
            super().__init__(
                ", ".join(
                    [
                        "value={!r}".format(value),
                    ]
                )
            )
            self.value = value

        def __repr__(self):
            return "KeyTransformationError.FromPkcs8({})".format(str(self))

    _UniffiTempKeyTransformationError.FromPkcs8 = FromPkcs8  # type: ignore

    class FromSec1(_UniffiTempKeyTransformationError):
        def __init__(self, value):
            super().__init__(
                ", ".join(
                    [
                        "value={!r}".format(value),
                    ]
                )
            )
            self.value = value

        def __repr__(self):
            return "KeyTransformationError.FromSec1({})".format(str(self))

    _UniffiTempKeyTransformationError.FromSec1 = FromSec1  # type: ignore

    class ToSec1(_UniffiTempKeyTransformationError):
        def __init__(self, value):
            super().__init__(
                ", ".join(
                    [
                        "value={!r}".format(value),
                    ]
                )
            )
            self.value = value

        def __repr__(self):
            return "KeyTransformationError.ToSec1({})".format(str(self))

    _UniffiTempKeyTransformationError.ToSec1 = ToSec1  # type: ignore


KeyTransformationError = _UniffiTempKeyTransformationError  # type: ignore
del _UniffiTempKeyTransformationError


class _UniffiConverterTypeKeyTransformationError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return KeyTransformationError.ToPkcs8(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return KeyTransformationError.FromPkcs8(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return KeyTransformationError.FromSec1(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return KeyTransformationError.ToSec1(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, KeyTransformationError.ToPkcs8):
            _UniffiConverterString.check_lower(value.value)
            return
        if isinstance(value, KeyTransformationError.FromPkcs8):
            _UniffiConverterString.check_lower(value.value)
            return
        if isinstance(value, KeyTransformationError.FromSec1):
            _UniffiConverterString.check_lower(value.value)
            return
        if isinstance(value, KeyTransformationError.ToSec1):
            _UniffiConverterString.check_lower(value.value)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, KeyTransformationError.ToPkcs8):
            buf.write_i32(1)
            _UniffiConverterString.write(value.value, buf)
        if isinstance(value, KeyTransformationError.FromPkcs8):
            buf.write_i32(2)
            _UniffiConverterString.write(value.value, buf)
        if isinstance(value, KeyTransformationError.FromSec1):
            buf.write_i32(3)
            _UniffiConverterString.write(value.value, buf)
        if isinstance(value, KeyTransformationError.ToSec1):
            buf.write_i32(4)
            _UniffiConverterString.write(value.value, buf)


class MDocItem:
    def __init__(self):
        raise RuntimeError("MDocItem cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class TEXT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(
                    f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'"
                )
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"MDocItem.TEXT{self._values!r}"

        def __eq__(self, other):
            if not other.is_text():
                return False
            return self._values == other._values

    class BOOL:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], bool):
                raise TypeError(
                    f"unexpected type for tuple element 0 - expected 'bool', got '{type(values[0])}'"
                )
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"MDocItem.BOOL{self._values!r}"

        def __eq__(self, other):
            if not other.is_bool():
                return False
            return self._values == other._values

    class INTEGER:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], int):
                raise TypeError(
                    f"unexpected type for tuple element 0 - expected 'int', got '{type(values[0])}'"
                )
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"MDocItem.INTEGER{self._values!r}"

        def __eq__(self, other):
            if not other.is_integer():
                return False
            return self._values == other._values

    class ITEM_MAP:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], dict[str, MDocItem]):
                raise TypeError(
                    f"unexpected type for tuple element 0 - expected 'dict[str, MDocItem]', got '{type(values[0])}'"
                )
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"MDocItem.ITEM_MAP{self._values!r}"

        def __eq__(self, other):
            if not other.is_item_map():
                return False
            return self._values == other._values

    class ARRAY:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], typing.List[MDocItem]):
                raise TypeError(
                    f"unexpected type for tuple element 0 - expected 'typing.List[MDocItem]', got '{type(values[0])}'"
                )
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"MDocItem.ARRAY{self._values!r}"

        def __eq__(self, other):
            if not other.is_array():
                return False
            return self._values == other._values

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_text(self) -> bool:
        return isinstance(self, MDocItem.TEXT)

    def is_bool(self) -> bool:
        return isinstance(self, MDocItem.BOOL)

    def is_integer(self) -> bool:
        return isinstance(self, MDocItem.INTEGER)

    def is_item_map(self) -> bool:
        return isinstance(self, MDocItem.ITEM_MAP)

    def is_array(self) -> bool:
        return isinstance(self, MDocItem.ARRAY)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
MDocItem.TEXT = type(
    "MDocItem.TEXT",
    (
        MDocItem.TEXT,
        MDocItem,
    ),
    {},
)  # type: ignore
MDocItem.BOOL = type(
    "MDocItem.BOOL",
    (
        MDocItem.BOOL,
        MDocItem,
    ),
    {},
)  # type: ignore
MDocItem.INTEGER = type(
    "MDocItem.INTEGER",
    (
        MDocItem.INTEGER,
        MDocItem,
    ),
    {},
)  # type: ignore
MDocItem.ITEM_MAP = type(
    "MDocItem.ITEM_MAP",
    (
        MDocItem.ITEM_MAP,
        MDocItem,
    ),
    {},
)  # type: ignore
MDocItem.ARRAY = type(
    "MDocItem.ARRAY",
    (
        MDocItem.ARRAY,
        MDocItem,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeMDocItem(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return MDocItem.TEXT(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return MDocItem.BOOL(
                _UniffiConverterBool.read(buf),
            )
        if variant == 3:
            return MDocItem.INTEGER(
                _UniffiConverterInt64.read(buf),
            )
        if variant == 4:
            return MDocItem.ITEM_MAP(
                _UniffiConverterMapStringTypeMDocItem.read(buf),
            )
        if variant == 5:
            return MDocItem.ARRAY(
                _UniffiConverterSequenceTypeMDocItem.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_text():
            _UniffiConverterString.check_lower(value._values[0])
            return
        if value.is_bool():
            _UniffiConverterBool.check_lower(value._values[0])
            return
        if value.is_integer():
            _UniffiConverterInt64.check_lower(value._values[0])
            return
        if value.is_item_map():
            _UniffiConverterMapStringTypeMDocItem.check_lower(value._values[0])
            return
        if value.is_array():
            _UniffiConverterSequenceTypeMDocItem.check_lower(value._values[0])
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_text():
            buf.write_i32(1)
            _UniffiConverterString.write(value._values[0], buf)
        if value.is_bool():
            buf.write_i32(2)
            _UniffiConverterBool.write(value._values[0], buf)
        if value.is_integer():
            buf.write_i32(3)
            _UniffiConverterInt64.write(value._values[0], buf)
        if value.is_item_map():
            buf.write_i32(4)
            _UniffiConverterMapStringTypeMDocItem.write(value._values[0], buf)
        if value.is_array():
            buf.write_i32(5)
            _UniffiConverterSequenceTypeMDocItem.write(value._values[0], buf)


# MdlReaderResponseError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class MdlReaderResponseError(Exception):
    pass


_UniffiTempMdlReaderResponseError = MdlReaderResponseError


class MdlReaderResponseError:  # type: ignore
    class InvalidDecryption(_UniffiTempMdlReaderResponseError):
        def __init__(self):
            pass

        def __repr__(self):
            return "MdlReaderResponseError.InvalidDecryption({})".format(str(self))

    _UniffiTempMdlReaderResponseError.InvalidDecryption = InvalidDecryption  # type: ignore

    class InvalidParsing(_UniffiTempMdlReaderResponseError):
        def __init__(self):
            pass

        def __repr__(self):
            return "MdlReaderResponseError.InvalidParsing({})".format(str(self))

    _UniffiTempMdlReaderResponseError.InvalidParsing = InvalidParsing  # type: ignore

    class InvalidIssuerAuthentication(_UniffiTempMdlReaderResponseError):
        def __init__(self):
            pass

        def __repr__(self):
            return "MdlReaderResponseError.InvalidIssuerAuthentication({})".format(
                str(self)
            )

    _UniffiTempMdlReaderResponseError.InvalidIssuerAuthentication = InvalidIssuerAuthentication  # type: ignore

    class InvalidDeviceAuthentication(_UniffiTempMdlReaderResponseError):
        def __init__(self):
            pass

        def __repr__(self):
            return "MdlReaderResponseError.InvalidDeviceAuthentication({})".format(
                str(self)
            )

    _UniffiTempMdlReaderResponseError.InvalidDeviceAuthentication = InvalidDeviceAuthentication  # type: ignore

    class Generic(_UniffiTempMdlReaderResponseError):
        def __init__(self, value):
            super().__init__(
                ", ".join(
                    [
                        "value={!r}".format(value),
                    ]
                )
            )
            self.value = value

        def __repr__(self):
            return "MdlReaderResponseError.Generic({})".format(str(self))

    _UniffiTempMdlReaderResponseError.Generic = Generic  # type: ignore


MdlReaderResponseError = _UniffiTempMdlReaderResponseError  # type: ignore
del _UniffiTempMdlReaderResponseError


class _UniffiConverterTypeMdlReaderResponseError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return MdlReaderResponseError.InvalidDecryption()
        if variant == 2:
            return MdlReaderResponseError.InvalidParsing()
        if variant == 3:
            return MdlReaderResponseError.InvalidIssuerAuthentication()
        if variant == 4:
            return MdlReaderResponseError.InvalidDeviceAuthentication()
        if variant == 5:
            return MdlReaderResponseError.Generic(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, MdlReaderResponseError.InvalidDecryption):
            return
        if isinstance(value, MdlReaderResponseError.InvalidParsing):
            return
        if isinstance(value, MdlReaderResponseError.InvalidIssuerAuthentication):
            return
        if isinstance(value, MdlReaderResponseError.InvalidDeviceAuthentication):
            return
        if isinstance(value, MdlReaderResponseError.Generic):
            _UniffiConverterString.check_lower(value.value)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, MdlReaderResponseError.InvalidDecryption):
            buf.write_i32(1)
        if isinstance(value, MdlReaderResponseError.InvalidParsing):
            buf.write_i32(2)
        if isinstance(value, MdlReaderResponseError.InvalidIssuerAuthentication):
            buf.write_i32(3)
        if isinstance(value, MdlReaderResponseError.InvalidDeviceAuthentication):
            buf.write_i32(4)
        if isinstance(value, MdlReaderResponseError.Generic):
            buf.write_i32(5)
            _UniffiConverterString.write(value.value, buf)


# MdlReaderResponseSerializeError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class MdlReaderResponseSerializeError(Exception):
    pass


_UniffiTempMdlReaderResponseSerializeError = MdlReaderResponseSerializeError


class MdlReaderResponseSerializeError:  # type: ignore
    class Generic(_UniffiTempMdlReaderResponseSerializeError):
        def __init__(self, value):
            super().__init__(
                ", ".join(
                    [
                        "value={!r}".format(value),
                    ]
                )
            )
            self.value = value

        def __repr__(self):
            return "MdlReaderResponseSerializeError.Generic({})".format(str(self))

    _UniffiTempMdlReaderResponseSerializeError.Generic = Generic  # type: ignore


MdlReaderResponseSerializeError = _UniffiTempMdlReaderResponseSerializeError  # type: ignore
del _UniffiTempMdlReaderResponseSerializeError


class _UniffiConverterTypeMdlReaderResponseSerializeError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return MdlReaderResponseSerializeError.Generic(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, MdlReaderResponseSerializeError.Generic):
            _UniffiConverterString.check_lower(value.value)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, MdlReaderResponseSerializeError.Generic):
            buf.write_i32(1)
            _UniffiConverterString.write(value.value, buf)


# MdlReaderSessionError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class MdlReaderSessionError(Exception):
    pass


_UniffiTempMdlReaderSessionError = MdlReaderSessionError


class MdlReaderSessionError:  # type: ignore
    class Generic(_UniffiTempMdlReaderSessionError):
        def __init__(self, value):
            super().__init__(
                ", ".join(
                    [
                        "value={!r}".format(value),
                    ]
                )
            )
            self.value = value

        def __repr__(self):
            return "MdlReaderSessionError.Generic({})".format(str(self))

    _UniffiTempMdlReaderSessionError.Generic = Generic  # type: ignore


MdlReaderSessionError = _UniffiTempMdlReaderSessionError  # type: ignore
del _UniffiTempMdlReaderSessionError


class _UniffiConverterTypeMdlReaderSessionError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return MdlReaderSessionError.Generic(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, MdlReaderSessionError.Generic):
            _UniffiConverterString.check_lower(value.value)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, MdlReaderSessionError.Generic):
            buf.write_i32(1)
            _UniffiConverterString.write(value.value, buf)


# MdlUtilError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class MdlUtilError(Exception):
    pass


_UniffiTempMdlUtilError = MdlUtilError


class MdlUtilError:  # type: ignore
    class General(_UniffiTempMdlUtilError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(
                    f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'"
                )
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "MdlUtilError.General({})".format(str(self))

    _UniffiTempMdlUtilError.General = General  # type: ignore


MdlUtilError = _UniffiTempMdlUtilError  # type: ignore
del _UniffiTempMdlUtilError


class _UniffiConverterTypeMdlUtilError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return MdlUtilError.General(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, MdlUtilError.General):
            _UniffiConverterString.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, MdlUtilError.General):
            buf.write_i32(1)
            _UniffiConverterString.write(value._values[0], buf)


# MdocEncodingError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class MdocEncodingError(Exception):
    pass


_UniffiTempMdocEncodingError = MdocEncodingError


class MdocEncodingError:  # type: ignore
    class DocumentCborEncoding(_UniffiTempMdocEncodingError):
        def __init__(self):
            pass

        def __repr__(self):
            return "MdocEncodingError.DocumentCborEncoding({})".format(str(self))

    _UniffiTempMdocEncodingError.DocumentCborEncoding = DocumentCborEncoding  # type: ignore

    class SerializationError(_UniffiTempMdocEncodingError):
        def __init__(self):
            pass

        def __repr__(self):
            return "MdocEncodingError.SerializationError({})".format(str(self))

    _UniffiTempMdocEncodingError.SerializationError = SerializationError  # type: ignore


MdocEncodingError = _UniffiTempMdocEncodingError  # type: ignore
del _UniffiTempMdocEncodingError


class _UniffiConverterTypeMdocEncodingError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return MdocEncodingError.DocumentCborEncoding()
        if variant == 2:
            return MdocEncodingError.SerializationError()
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, MdocEncodingError.DocumentCborEncoding):
            return
        if isinstance(value, MdocEncodingError.SerializationError):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, MdocEncodingError.DocumentCborEncoding):
            buf.write_i32(1)
        if isinstance(value, MdocEncodingError.SerializationError):
            buf.write_i32(2)


# MdocInitError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class MdocInitError(Exception):
    pass


_UniffiTempMdocInitError = MdocInitError


class MdocInitError:  # type: ignore
    class DocumentCborDecoding(_UniffiTempMdocInitError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(
                    f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'"
                )
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "MdocInitError.DocumentCborDecoding({})".format(str(self))

    _UniffiTempMdocInitError.DocumentCborDecoding = DocumentCborDecoding  # type: ignore

    class IssuerSignedBase64UrlDecoding(_UniffiTempMdocInitError):
        def __init__(self):
            pass

        def __repr__(self):
            return "MdocInitError.IssuerSignedBase64UrlDecoding({})".format(str(self))

    _UniffiTempMdocInitError.IssuerSignedBase64UrlDecoding = IssuerSignedBase64UrlDecoding  # type: ignore

    class IssuerSignedCborDecoding(_UniffiTempMdocInitError):
        def __init__(self):
            pass

        def __repr__(self):
            return "MdocInitError.IssuerSignedCborDecoding({})".format(str(self))

    _UniffiTempMdocInitError.IssuerSignedCborDecoding = IssuerSignedCborDecoding  # type: ignore

    class IssuerAuthPayloadMissing(_UniffiTempMdocInitError):
        def __init__(self):
            pass

        def __repr__(self):
            return "MdocInitError.IssuerAuthPayloadMissing({})".format(str(self))

    _UniffiTempMdocInitError.IssuerAuthPayloadMissing = IssuerAuthPayloadMissing  # type: ignore

    class IssuerAuthPayloadDecoding(_UniffiTempMdocInitError):
        def __init__(self):
            pass

        def __repr__(self):
            return "MdocInitError.IssuerAuthPayloadDecoding({})".format(str(self))

    _UniffiTempMdocInitError.IssuerAuthPayloadDecoding = IssuerAuthPayloadDecoding  # type: ignore

    class KeyAliasMissing(_UniffiTempMdocInitError):
        def __init__(self):
            pass

        def __repr__(self):
            return "MdocInitError.KeyAliasMissing({})".format(str(self))

    _UniffiTempMdocInitError.KeyAliasMissing = KeyAliasMissing  # type: ignore

    class NamespacesMissing(_UniffiTempMdocInitError):
        def __init__(self):
            pass

        def __repr__(self):
            return "MdocInitError.NamespacesMissing({})".format(str(self))

    _UniffiTempMdocInitError.NamespacesMissing = NamespacesMissing  # type: ignore

    class DocumentUtf8Decoding(_UniffiTempMdocInitError):
        def __init__(self):
            pass

        def __repr__(self):
            return "MdocInitError.DocumentUtf8Decoding({})".format(str(self))

    _UniffiTempMdocInitError.DocumentUtf8Decoding = DocumentUtf8Decoding  # type: ignore

    class InvalidJwk(_UniffiTempMdocInitError):
        def __init__(self):
            pass

        def __repr__(self):
            return "MdocInitError.InvalidJwk({})".format(str(self))

    _UniffiTempMdocInitError.InvalidJwk = InvalidJwk  # type: ignore

    class GeneralConstructionError(_UniffiTempMdocInitError):
        def __init__(self):
            pass

        def __repr__(self):
            return "MdocInitError.GeneralConstructionError({})".format(str(self))

    _UniffiTempMdocInitError.GeneralConstructionError = GeneralConstructionError  # type: ignore


MdocInitError = _UniffiTempMdocInitError  # type: ignore
del _UniffiTempMdocInitError


class _UniffiConverterTypeMdocInitError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return MdocInitError.DocumentCborDecoding(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return MdocInitError.IssuerSignedBase64UrlDecoding()
        if variant == 3:
            return MdocInitError.IssuerSignedCborDecoding()
        if variant == 4:
            return MdocInitError.IssuerAuthPayloadMissing()
        if variant == 5:
            return MdocInitError.IssuerAuthPayloadDecoding()
        if variant == 6:
            return MdocInitError.KeyAliasMissing()
        if variant == 7:
            return MdocInitError.NamespacesMissing()
        if variant == 8:
            return MdocInitError.DocumentUtf8Decoding()
        if variant == 9:
            return MdocInitError.InvalidJwk()
        if variant == 10:
            return MdocInitError.GeneralConstructionError()
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, MdocInitError.DocumentCborDecoding):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, MdocInitError.IssuerSignedBase64UrlDecoding):
            return
        if isinstance(value, MdocInitError.IssuerSignedCborDecoding):
            return
        if isinstance(value, MdocInitError.IssuerAuthPayloadMissing):
            return
        if isinstance(value, MdocInitError.IssuerAuthPayloadDecoding):
            return
        if isinstance(value, MdocInitError.KeyAliasMissing):
            return
        if isinstance(value, MdocInitError.NamespacesMissing):
            return
        if isinstance(value, MdocInitError.DocumentUtf8Decoding):
            return
        if isinstance(value, MdocInitError.InvalidJwk):
            return
        if isinstance(value, MdocInitError.GeneralConstructionError):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, MdocInitError.DocumentCborDecoding):
            buf.write_i32(1)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, MdocInitError.IssuerSignedBase64UrlDecoding):
            buf.write_i32(2)
        if isinstance(value, MdocInitError.IssuerSignedCborDecoding):
            buf.write_i32(3)
        if isinstance(value, MdocInitError.IssuerAuthPayloadMissing):
            buf.write_i32(4)
        if isinstance(value, MdocInitError.IssuerAuthPayloadDecoding):
            buf.write_i32(5)
        if isinstance(value, MdocInitError.KeyAliasMissing):
            buf.write_i32(6)
        if isinstance(value, MdocInitError.NamespacesMissing):
            buf.write_i32(7)
        if isinstance(value, MdocInitError.DocumentUtf8Decoding):
            buf.write_i32(8)
        if isinstance(value, MdocInitError.InvalidJwk):
            buf.write_i32(9)
        if isinstance(value, MdocInitError.GeneralConstructionError):
            buf.write_i32(10)


# RequestError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class RequestError(Exception):
    pass


_UniffiTempRequestError = RequestError


class RequestError:  # type: ignore
    class Generic(_UniffiTempRequestError):
        def __init__(self, value):
            super().__init__(
                ", ".join(
                    [
                        "value={!r}".format(value),
                    ]
                )
            )
            self.value = value

        def __repr__(self):
            return "RequestError.Generic({})".format(str(self))

    _UniffiTempRequestError.Generic = Generic  # type: ignore


RequestError = _UniffiTempRequestError  # type: ignore
del _UniffiTempRequestError


class _UniffiConverterTypeRequestError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RequestError.Generic(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, RequestError.Generic):
            _UniffiConverterString.check_lower(value.value)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, RequestError.Generic):
            buf.write_i32(1)
            _UniffiConverterString.write(value.value, buf)


# ResponseError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class ResponseError(Exception):
    pass


_UniffiTempResponseError = ResponseError


class ResponseError:  # type: ignore
    class MissingSignature(_UniffiTempResponseError):
        def __init__(self):
            pass

        def __repr__(self):
            return "ResponseError.MissingSignature({})".format(str(self))

    _UniffiTempResponseError.MissingSignature = MissingSignature  # type: ignore

    class Generic(_UniffiTempResponseError):
        def __init__(self, value):
            super().__init__(
                ", ".join(
                    [
                        "value={!r}".format(value),
                    ]
                )
            )
            self.value = value

        def __repr__(self):
            return "ResponseError.Generic({})".format(str(self))

    _UniffiTempResponseError.Generic = Generic  # type: ignore


ResponseError = _UniffiTempResponseError  # type: ignore
del _UniffiTempResponseError


class _UniffiConverterTypeResponseError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ResponseError.MissingSignature()
        if variant == 2:
            return ResponseError.Generic(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, ResponseError.MissingSignature):
            return
        if isinstance(value, ResponseError.Generic):
            _UniffiConverterString.check_lower(value.value)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, ResponseError.MissingSignature):
            buf.write_i32(1)
        if isinstance(value, ResponseError.Generic):
            buf.write_i32(2)
            _UniffiConverterString.write(value.value, buf)


# SessionError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class SessionError(Exception):
    pass


_UniffiTempSessionError = SessionError


class SessionError:  # type: ignore
    class Generic(_UniffiTempSessionError):
        def __init__(self, value):
            super().__init__(
                ", ".join(
                    [
                        "value={!r}".format(value),
                    ]
                )
            )
            self.value = value

        def __repr__(self):
            return "SessionError.Generic({})".format(str(self))

    _UniffiTempSessionError.Generic = Generic  # type: ignore


SessionError = _UniffiTempSessionError  # type: ignore
del _UniffiTempSessionError


class _UniffiConverterTypeSessionError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SessionError.Generic(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, SessionError.Generic):
            _UniffiConverterString.check_lower(value.value)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, SessionError.Generic):
            buf.write_i32(1)
            _UniffiConverterString.write(value.value, buf)


# SignatureError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class SignatureError(Exception):
    pass


_UniffiTempSignatureError = SignatureError


class SignatureError:  # type: ignore
    class InvalidSignature(_UniffiTempSignatureError):
        def __init__(self, value):
            super().__init__(
                ", ".join(
                    [
                        "value={!r}".format(value),
                    ]
                )
            )
            self.value = value

        def __repr__(self):
            return "SignatureError.InvalidSignature({})".format(str(self))

    _UniffiTempSignatureError.InvalidSignature = InvalidSignature  # type: ignore

    class TooManyDocuments(_UniffiTempSignatureError):
        def __init__(self):
            pass

        def __repr__(self):
            return "SignatureError.TooManyDocuments({})".format(str(self))

    _UniffiTempSignatureError.TooManyDocuments = TooManyDocuments  # type: ignore

    class Generic(_UniffiTempSignatureError):
        def __init__(self, value):
            super().__init__(
                ", ".join(
                    [
                        "value={!r}".format(value),
                    ]
                )
            )
            self.value = value

        def __repr__(self):
            return "SignatureError.Generic({})".format(str(self))

    _UniffiTempSignatureError.Generic = Generic  # type: ignore


SignatureError = _UniffiTempSignatureError  # type: ignore
del _UniffiTempSignatureError


class _UniffiConverterTypeSignatureError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SignatureError.InvalidSignature(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return SignatureError.TooManyDocuments()
        if variant == 3:
            return SignatureError.Generic(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, SignatureError.InvalidSignature):
            _UniffiConverterString.check_lower(value.value)
            return
        if isinstance(value, SignatureError.TooManyDocuments):
            return
        if isinstance(value, SignatureError.Generic):
            _UniffiConverterString.check_lower(value.value)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, SignatureError.InvalidSignature):
            buf.write_i32(1)
            _UniffiConverterString.write(value.value, buf)
        if isinstance(value, SignatureError.TooManyDocuments):
            buf.write_i32(2)
        if isinstance(value, SignatureError.Generic):
            buf.write_i32(3)
            _UniffiConverterString.write(value.value, buf)


# TerminationError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class TerminationError(Exception):
    pass


_UniffiTempTerminationError = TerminationError


class TerminationError:  # type: ignore
    class Generic(_UniffiTempTerminationError):
        def __init__(self, value):
            super().__init__(
                ", ".join(
                    [
                        "value={!r}".format(value),
                    ]
                )
            )
            self.value = value

        def __repr__(self):
            return "TerminationError.Generic({})".format(str(self))

    _UniffiTempTerminationError.Generic = Generic  # type: ignore


TerminationError = _UniffiTempTerminationError  # type: ignore
del _UniffiTempTerminationError


class _UniffiConverterTypeTerminationError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TerminationError.Generic(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, TerminationError.Generic):
            _UniffiConverterString.check_lower(value.value)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, TerminationError.Generic):
            buf.write_i32(1)
            _UniffiConverterString.write(value.value, buf)


class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class _UniffiConverterOptionalSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class _UniffiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterString.read(buf) for i in range(count)]


class _UniffiConverterSequenceTypeElement(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeElement.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeElement.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterTypeElement.read(buf) for i in range(count)]


class _UniffiConverterSequenceTypeItemsRequest(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeItemsRequest.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeItemsRequest.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterTypeItemsRequest.read(buf) for i in range(count)]


class _UniffiConverterSequenceTypeMDocItem(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeMDocItem.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeMDocItem.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterTypeMDocItem.read(buf) for i in range(count)]


class _UniffiConverterMapStringBool(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterBool.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterBool.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterBool.read(buf)
            d[key] = val
        return d


class _UniffiConverterMapStringBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterBytes.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterBytes.read(buf)
            d[key] = val
        return d


class _UniffiConverterMapStringTypeMDocItem(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterTypeMDocItem.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterTypeMDocItem.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterTypeMDocItem.read(buf)
            d[key] = val
        return d


class _UniffiConverterMapStringSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterSequenceString.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterSequenceString.read(buf)
            d[key] = val
        return d


class _UniffiConverterMapStringMapStringBool(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterMapStringBool.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterMapStringBool.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterMapStringBool.read(buf)
            d[key] = val
        return d


class _UniffiConverterMapStringMapStringBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterMapStringBytes.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterMapStringBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterMapStringBytes.read(buf)
            d[key] = val
        return d


class _UniffiConverterMapStringMapStringTypeMDocItem(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterMapStringTypeMDocItem.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterMapStringTypeMDocItem.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterMapStringTypeMDocItem.read(buf)
            d[key] = val
        return d


class _UniffiConverterMapStringMapStringSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterMapStringSequenceString.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterMapStringSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterMapStringSequenceString.read(buf)
            d[key] = val
        return d


class _UniffiConverterMapTypeNamespaceSequenceTypeElement(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeNamespace.check_lower(key)
            _UniffiConverterSequenceTypeElement.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeNamespace.write(key, buf)
            _UniffiConverterSequenceTypeElement.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeNamespace.read(buf)
            val = _UniffiConverterSequenceTypeElement.read(buf)
            d[key] = val
        return d


class _UniffiConverterTypeKeyAlias:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypeNamespace:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypeUuid:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


KeyAlias = str
Namespace = str
Uuid = str

# Async support


def establish_session(
    uri: "str",
    requested_items: "dict[str, dict[str, bool]]",
    trust_anchor_registry: "typing.Optional[typing.List[str]]",
) -> "MdlReaderSessionData":
    _UniffiConverterString.check_lower(uri)

    _UniffiConverterMapStringMapStringBool.check_lower(requested_items)

    _UniffiConverterOptionalSequenceString.check_lower(trust_anchor_registry)

    return _UniffiConverterTypeMdlReaderSessionData.lift(
        _uniffi_rust_call_with_error(
            _UniffiConverterTypeMdlReaderSessionError,
            _UniffiLib.uniffi_isomdl_uniffi_fn_func_establish_session,
            _UniffiConverterString.lower(uri),
            _UniffiConverterMapStringMapStringBool.lower(requested_items),
            _UniffiConverterOptionalSequenceString.lower(trust_anchor_registry),
        )
    )


def generate_test_mdl(key_pair: "P256KeyPair") -> "Mdoc":
    """
    Generate a new test mDL with hardcoded values, using the supplied key as the DeviceKey.
    """

    _UniffiConverterTypeP256KeyPair.check_lower(key_pair)

    return _UniffiConverterTypeMdoc.lift(
        _uniffi_rust_call_with_error(
            _UniffiConverterTypeMdlUtilError,
            _UniffiLib.uniffi_isomdl_uniffi_fn_func_generate_test_mdl,
            _UniffiConverterTypeP256KeyPair.lower(key_pair),
        )
    )


def handle_response(
    state: "MdlSessionManager", response: "bytes"
) -> "MdlReaderResponseData":
    _UniffiConverterTypeMdlSessionManager.check_lower(state)

    _UniffiConverterBytes.check_lower(response)

    return _UniffiConverterTypeMdlReaderResponseData.lift(
        _uniffi_rust_call_with_error(
            _UniffiConverterTypeMdlReaderResponseError,
            _UniffiLib.uniffi_isomdl_uniffi_fn_func_handle_response,
            _UniffiConverterTypeMdlSessionManager.lower(state),
            _UniffiConverterBytes.lower(response),
        )
    )


def iso1801351_aamva_from_json(json: "str") -> "dict[str, bytes]":
    _UniffiConverterString.check_lower(json)

    return _UniffiConverterMapStringBytes.lift(
        _uniffi_rust_call_with_error(
            _UniffiConverterTypeMdlUtilError,
            _UniffiLib.uniffi_isomdl_uniffi_fn_func_iso1801351_aamva_from_json,
            _UniffiConverterString.lower(json),
        )
    )


def iso1801351_from_json(json: "str") -> "dict[str, bytes]":
    _UniffiConverterString.check_lower(json)

    return _UniffiConverterMapStringBytes.lift(
        _uniffi_rust_call_with_error(
            _UniffiConverterTypeMdlUtilError,
            _UniffiLib.uniffi_isomdl_uniffi_fn_func_iso1801351_from_json,
            _UniffiConverterString.lower(json),
        )
    )


def verified_response_as_json_string(response: "MdlReaderResponseData") -> "str":
    _UniffiConverterTypeMdlReaderResponseData.check_lower(response)

    return _UniffiConverterString.lift(
        _uniffi_rust_call_with_error(
            _UniffiConverterTypeMdlReaderResponseSerializeError,
            _UniffiLib.uniffi_isomdl_uniffi_fn_func_verified_response_as_json_string,
            _UniffiConverterTypeMdlReaderResponseData.lower(response),
        )
    )


__all__ = [
    "InternalError",
    "AuthenticationStatus",
    "KeyTransformationError",
    "MDocItem",
    "MdlReaderResponseError",
    "MdlReaderResponseSerializeError",
    "MdlReaderSessionError",
    "MdlUtilError",
    "MdocEncodingError",
    "MdocInitError",
    "RequestError",
    "ResponseError",
    "SessionError",
    "SignatureError",
    "TerminationError",
    "Element",
    "ItemsRequest",
    "MdlReaderResponseData",
    "MdlReaderSessionData",
    "establish_session",
    "generate_test_mdl",
    "handle_response",
    "iso1801351_aamva_from_json",
    "iso1801351_from_json",
    "verified_response_as_json_string",
    "InProcessRecord",
    "MdlSessionManager",
    "MdlPresentationSession",
    "Mdoc",
    "P256KeyPair",
]
